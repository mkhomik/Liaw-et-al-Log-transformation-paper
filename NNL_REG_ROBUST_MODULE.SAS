* MODULE FILE NAME: NNL_REG_ROBUST_MODULE.SAS;
* THIS MODULE IS FOR ESTIMATING THE COEFFICIENTS OF A MODEL IN THE 
* EXPONENTIAL FAMILY BY A NONLINEAR LEAST SQUARES METHOD, 
* ORIGINALLY WRITTEN BY KAO-LEE LIAW IN 2013;
* SPECIFICATION OF VARIABLES THAT CAN BE CHANGED BY THE USER:
*   N_ITER = MAXIMUM NO. OF ITERATIONS OF THE NEWTON-RAPHSON ALGORITHM.
*   DETAIL = 1 (IF YOU WANT TO SEE THE INFORMATION AT EACH ITERATION).
*   BL_SIZE = NO. OF OBSERVATIONS PER BUNCH. 
*            IT MUST NOT BE BIGGER THAN THE SAMPLE SIZE. IF YOUR COMPUTER
*            HAS A SMALL MEMORY, YOU CAN REDUCE THE VALUE OF BL_SIZE.
*   STEPSIZE = A SCALAR TO ADJUST THE SIZE OF THE CHANGE IN THE PARAMETER
*              VECTOR FROM ONE ITERATION TO THE NEXT. IT MUST BE A 
*              POSITIVE VALUE LESS THAN OR EQUAL TO 1. WHEN IT IS SET TO 1,
*              THE COMPUTATION TAKES THE LEAST AMOUNT OF TIME BUT THE RISK
*              OF DIVERGENCE MAY BE THE HIGHEST.
*              WHEN CONVERGENCE FAILED, TRY USING A SMALLER STEP SIZE.
*   Y = COLUMN VECTOR OF THE DEPENDENT VARIABLE.
*   INDEP = COLUMN VECTOR WITH NAMES OF EXPLANATORY VARIABLES,
*           WITH THE FIRST VARIABLE BEING THE COLUMN REPRESENTING THE
*           INTERCEPT.
*  Technical Advice:
*  IF YOU GET AN "OVERFLOW" ERROR MESSAGE, YOU SHOULD CHANGE THE SCALE OF
*  YOUR DEPENDENT VARIABLE BY DIVIDING A LARGE NUMBER (E.G. 1000) INTO IT;
START NNL_REG_ROBUST ;
N_ITER = 200;
DETAIL = 0;
STEPSIZE = 0.8;
READ all var{&DEP_VAR} into Y;
READ all var{&indep} into X;
NOBS=NROW(Y);
IF NOBS > 500 THEN BL_SIZE = 500;
ELSE BL_SIZE = NOBS;
LEFTOVER=MOD(NOBS,BL_SIZE);
NBUNCH=INT(NOBS/BL_SIZE);
Y_MEAN =SUM(Y)/NOBS;
B = REPEAT(0,NCOL(X),1); OLDB=B+1; /* STARTING VALUES */
* BEGINNING OF ITERATIONS;
DO ITER = 1 TO N_ITER;
      OLDB=B;
      XPX=REPEAT(0,NCOL(X),NCOL(X));
      XPY=REPEAT(0,NCOL(X),1);

     XPX_RB=XPX;

      SSQ=0;   SSQ0=0;
      RSRMSQ=0;
      DO IBUNCH=1 TO NBUNCH;
        N1=(IBUNCH-1)*BL_SIZE+1;
        N2=N1+BL_SIZE-1;
 Y_NULL=REPEAT(Y_MEAN, BL_SIZE);
        Y_HAT=EXP(X[N1:N2, ]*B);
       DER=X[N1:N2, ]#Y_HAT;
	 * DER is part of the Jacobian;
     DIFF_I=Y[N1:N2] - Y_HAT;
	 DIFF_0=Y[N1:N2] - Y_NULL;
      SSQ = SSQ + SUM(DIFF_I # DIFF_I);
   SSQ0 = SSQ0 + SUM(DIFF_0 # DIFF_0);
          DERT=(DER)`;
        DERT_RB=(DER#DIFF_I#DIFF_I)`;
		XPX_RB= XPX_RB + DERT_RB*DER;

        XPX= XPX + DERT*DER; /* BUILDING UP THE INFORMATION MATRIX */
        XPY= XPY + DERT*DIFF_I;
      END;/*IBUNCH*/
    IF LEFTOVER > 0 THEN DO;
        N1=NBUNCH*BL_SIZE+1;
        N2=N1+LEFTOVER-1;
 Y_NULL=REPEAT(Y_MEAN, LEFTOVER);
        Y_HAT=EXP(X[N1:N2, ]*B);
       DER=X[N1:N2, ]#Y_HAT;
     DIFF_I=Y[N1:N2] - Y_HAT;
	 DIFF_0=Y[N1:N2] - Y_NULL;
      SSQ = SSQ + SUM(DIFF_I # DIFF_I);
SSQ0 = SSQ0 + SUM(DIFF_0 # DIFF_0);
          DERT=(DER)`;
        DERT_RB=(DER#DIFF_I#DIFF_I)`;
        XPX_RB= XPX_RB + DERT_RB*DER;

        XPX= XPX + DERT*DER; /* BUILDING UP THE INFORMATION MATRIX */
        XPY= XPY + DERT*DIFF_I;
                          END; /* At this point, the construction of the Information Matrix is completed */
      btransp = b`;
      IF DETAIL = 1 THEN print iter SSQ btransp;
      XPX = INV(XPX);/* NOW XPX IS THE INVERSE OF INFORMATION MATRIX  */
      B = B + STEPSIZE*( XPX * XPY);/* REDUCE THE STEP SIZE, IF THE MODULE DOES NOT CONVERGE */
      IF MAX(ABS(B-OLDB))<1E-8 THEN DO;/* BEGINNING OF THE FINAL PART*/
	  DF_ESS = NOBS - NCOL(X) ;
   NVAR=NCOL(X)-1;
   RSRMSQ=SQRT(SSQ/DF_ESS);/* RESIDUAL ROOT_MEAN_SQUARE */
   RSRMSQ0=SQRT(SSQ0/(NOBS-1));/* RESIDUAL ROOT_MEAN_SQUARE OF THE NULL MODEL */
   R_SQUARE = (SSQ0 - SSQ) / SSQ0;
   ADJ_R_SQ= 1 - (RSRMSQ/RSRMSQ0)**2;
   PRINT  NOBS NVAR  Y_MEAN ITER ;
   PRINT  SSQ SSQ0 RSRMSQ DF_ESS  RSRMSQ0 R_SQUARE ADJ_R_SQ;

   CV_RB=XPX * XPX_RB * XPX;
   STD_ERR_ROBUST = SQRT(VECDIAG(CV_RB));
   T_RATIO_ROBUST = B/STD_ERR_ROBUST;
   P_VALUE_ROBUST = (1 - PROBT(ABS(T_RATIO_ROBUST),DF_ESS))*2;

   STD_ERR_HOMO = SQRT(VECDIAG(XPX))*RSRMSQ;
   T_RATIO_HOMO = B/STD_ERR_HOMO;
   P_VALUE_HOMO = (1 - PROBT(ABS(T_RATIO_HOMO),DF_ESS))*2;
   VAR_NAME={&INDEP}`;
   COEFFICIENT = B ;
   PRINT "ESTIMATED RESULT: STD_ERR_HOMO, T_RATIO_HOMO, and P_VALUE_HOMO are based the HOMOSCEDASTICITY assumption.";
   PRINT "NOTE: THE INFORMATION IN THIS TABLE IS ALSO CONTAINED IN THE SAS DATA SET 'PARM_FL'.";
   PRINT VAR_NAME COEFFICIENT[FORMAT=13.6] STD_ERR_HOMO[FORMAT=13.6] T_RATIO_HOMO[FORMAT=10.2] P_VALUE_HOMO[FORMAT=10.6];  

   PRINT "ESTIMATED RESULT: STD_ERR_ROBUST, T_RATIO_ROBUST, and P_VALUE_ROUST are based on the HETEROSCEDASTICITY assumption.";
   PRINT "NOTE: THE INFORMATION IN THIS TABLE IS ALSO CONTAINED IN THE SAS DATA SET 'PARM_FL'.";
   PRINT VAR_NAME COEFFICIENT[FORMAT=13.6] STD_ERR_ROBUST[FORMAT=13.6] T_RATIO_ROBUST[FORMAT=10.2] P_VALUE_ROBUST[FORMAT=10.6];
/* CREATE THE DATA SET CONTAINING THE ESTIMATED PARAMETERS AND RELATED STATISTICS */
   CREATE PARM_FL VAR{VAR_NAME COEFFICIENT  STD_ERR_ROBUST T_RATIO_ROBUST P_VALUE_ROBUST STD_ERR_HOMO T_RATIO_HOMO P_VALUE_HOMO};
   APPEND;
   CLOSE PARM_FL;
/* CREATE THE DATA SET CONTAINING THE PREDICTED VALUES OF THE DEPENDENT VARIBLE */
         CREATE Y_HAT_FILE VAR{Y_HAT};
DO IBUNCH=1 TO NBUNCH;
        N1=(IBUNCH-1)*BL_SIZE+1;
        N2=N1+BL_SIZE-1;
         Y_HAT=EXP(X[N1:N2, ]*B);
		 APPEND;
 END;
 IF LEFTOVER > 0 THEN DO;
        N1=NBUNCH*BL_SIZE+1;
        N2=N1+LEFTOVER-1;
        Y_HAT=EXP(X[N1:N2, ]*B);
		APPEND;
                      END;
        CLOSE Y_HAT_FILE;
        STOP; 
                                    END;/*END OF THE FINAL PART*/ 
   END; /* END OF ITER LOOP:  THE MAXIMUM NUMBER OF ITERATIONS IS REACHED HERE  */
      PRINT "!!! WARNING!!!: THE ESTIMATED PARAMETERS MAY NOT BE MEANINGFUL,";
      PRINT "BECAUSE THE MAXIMUM NO. OF ITERATIONS IS REACHED.";
						   STOP;
FINISH ;/* END OF NNL_REG_ROBUST */
*  OUTPUT VARIABLES: 
*   NOBS = NO. OF OBSERVATIONS.
*   NVAR = NO. OF SUBSTATIVE EXPLANATORY VARIABLES.
*   Y_MEAN = MEAN OF THE DEPENDENT VARIABLE.
*   ITER = THE NUNBER OF ITERATIONS AT CONVERGENCE.
*   SSQ = RESIDUAL SUM OF SQUARES.
*   SSQ0 = TOTAL SUM OF SQUARES.
*   RSRMSQ = RESIDUAL ROOT_MEAN_SQUARE.
*   RSRMSQ0 =  RESIDUAL ROOT_MEAN_SQUARE OF THE NULL MODEL.
*   R_SQUARE.
*   ADJ_R_SQ= ADJUSTED R_SQUARE.
* OUTPUT DATA SETS:
*  (1) PARM_FL:
*     VAR_NAME=A COLUMN VETCTOR CONTAINING THE VARIABLE NAMES.
*     COEFFICIENT = A COLUMN VECTOR CONTAINING THE ESTIMATED COEFFICIENTS.
*     STD_ERR_ROBUST = A COLUMN VECTOR CONTAINING THE ROBUST STANDARD ERRORS 
*                OF THE COEFFICIENTS, BASED ON HETEROSCEDASTICITY ASSUMPTION.
*     T_RATIO_ROBUST = A COLUMN VECTOR OF ROBUST T-STATISTICS.
*     P_VALUE_ROBUST = A COLUMN VECTOR CONTAINING THE P_VALUES, BASED ON 
*               T_RATIO_ROBUST.
*     STD_ERR_HOMO = A COLUMN VECTOR CONTAINING THE STANDARD ERRORS OF 
*                    THE COEFFICIENTS, WHICH ARE BASED ON THE 
*                    HOMOSCEDASTICITY ASSUMPTION.
*     T_RATIO_HOMO = A COLUMN VECTOR CONATAINING THE T_STATISTICS, WHICH ARE
*                    BASED ON THE HOMOSCEDASTICITY ASSUMPTION.
*     P_VALUE_HOMO = A COLUMN VECTOR CONTAINING THE P_VALUES, BASED ON 
*                    T_RATIO_HOMO.
*  (2) Y_HAT_FILE: THIS DATA SET CONTAINS THE PREDICTED VALUES OF THE 
*                  DEPENDENT VARIABLE (Y_HAT);
/*********************** END OF THE MODULE ************************/
